// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210601previewstorage

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/microsoft.servicebus/v1alpha1api20210101previewstorage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Storage version of v1alpha1api20210601preview.Namespace
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/resourceDefinitions/namespaces
type Namespace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Namespaces_Spec    `json:"spec,omitempty"`
	Status            SBNamespace_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Namespace{}

// GetConditions returns the conditions of the resource
func (namespace *Namespace) GetConditions() conditions.Conditions {
	return namespace.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (namespace *Namespace) SetConditions(conditions conditions.Conditions) {
	namespace.Status.Conditions = conditions
}

var _ conversion.Convertible = &Namespace{}

// ConvertFrom populates our Namespace from the provided hub Namespace
func (namespace *Namespace) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1alpha1api20210101previewstorage.Namespace)
	if !ok {
		return fmt.Errorf("expected storage:microsoft.servicebus/v1alpha1api20210101previewstorage/Namespace but received %T instead", hub)
	}

	return namespace.AssignPropertiesFromNamespace(source)
}

// ConvertTo populates the provided hub Namespace from our Namespace
func (namespace *Namespace) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1alpha1api20210101previewstorage.Namespace)
	if !ok {
		return fmt.Errorf("expected storage:microsoft.servicebus/v1alpha1api20210101previewstorage/Namespace but received %T instead", hub)
	}

	return namespace.AssignPropertiesToNamespace(destination)
}

var _ genruntime.KubernetesResource = &Namespace{}

// AzureName returns the Azure name of the resource
func (namespace *Namespace) AzureName() string {
	return namespace.Spec.AzureName
}

// GetResourceKind returns the kind of the resource
func (namespace *Namespace) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (namespace *Namespace) GetSpec() genruntime.ConvertibleSpec {
	return &namespace.Spec
}

// GetStatus returns the status of this resource
func (namespace *Namespace) GetStatus() genruntime.ConvertibleStatus {
	return &namespace.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ServiceBus/namespaces"
func (namespace *Namespace) GetType() string {
	return "Microsoft.ServiceBus/namespaces"
}

// NewEmptyStatus returns a new empty (blank) status
func (namespace *Namespace) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &SBNamespace_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (namespace *Namespace) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(namespace.Spec)
	return &genruntime.ResourceReference{
		Group:     group,
		Kind:      kind,
		Namespace: namespace.Namespace,
		Name:      namespace.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (namespace *Namespace) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*SBNamespace_Status); ok {
		namespace.Status = *st
		return nil
	}

	// Convert status to required version
	var st SBNamespace_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	namespace.Status = st
	return nil
}

// AssignPropertiesFromNamespace populates our Namespace from the provided source Namespace
func (namespace *Namespace) AssignPropertiesFromNamespace(source *v1alpha1api20210101previewstorage.Namespace) error {

	// Spec
	var spec Namespaces_Spec
	err := spec.AssignPropertiesFromNamespacesSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromNamespacesSpec()")
	}
	namespace.Spec = spec

	// Status
	var status SBNamespace_Status
	err = status.AssignPropertiesFromSBNamespaceStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromSBNamespaceStatus()")
	}
	namespace.Status = status

	// No error
	return nil
}

// AssignPropertiesToNamespace populates the provided destination Namespace from our Namespace
func (namespace *Namespace) AssignPropertiesToNamespace(destination *v1alpha1api20210101previewstorage.Namespace) error {

	// Spec
	var spec v1alpha1api20210101previewstorage.Namespaces_Spec
	err := namespace.Spec.AssignPropertiesToNamespacesSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToNamespacesSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20210101previewstorage.SBNamespace_Status
	err = namespace.Status.AssignPropertiesToSBNamespaceStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToSBNamespaceStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (namespace *Namespace) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: namespace.Spec.OriginalVersion,
		Kind:    "Namespace",
	}
}

// +kubebuilder:object:root=true
//Storage version of v1alpha1api20210601preview.Namespace
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/resourceDefinitions/namespaces
type NamespaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Namespace `json:"items"`
}

//Storage version of v1alpha1api20210601preview.Namespaces_Spec
type Namespaces_Spec struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName        string      `json:"azureName"`
	DisableLocalAuth *bool       `json:"disableLocalAuth,omitempty"`
	Encryption       *Encryption `json:"encryption,omitempty"`
	Identity         *Identity   `json:"identity,omitempty"`
	Location         *string     `json:"location,omitempty"`
	OriginalVersion  string      `json:"originalVersion"`

	// +kubebuilder:validation:Required
	Owner         genruntime.KnownResourceReference `group:"microsoft.resources.azure.com" json:"owner" kind:"ResourceGroup"`
	PropertyBag   genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	Sku           *SBSku                            `json:"sku,omitempty"`
	Tags          map[string]string                 `json:"tags,omitempty"`
	ZoneRedundant *bool                             `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ConvertibleSpec = &Namespaces_Spec{}

// ConvertSpecFrom populates our Namespaces_Spec from the provided source
func (namespacesSpec *Namespaces_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20210101previewstorage.Namespaces_Spec)
	if ok {
		// Populate our instance from source
		return namespacesSpec.AssignPropertiesFromNamespacesSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210101previewstorage.Namespaces_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = namespacesSpec.AssignPropertiesFromNamespacesSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Namespaces_Spec
func (namespacesSpec *Namespaces_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20210101previewstorage.Namespaces_Spec)
	if ok {
		// Populate destination from our instance
		return namespacesSpec.AssignPropertiesToNamespacesSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210101previewstorage.Namespaces_Spec{}
	err := namespacesSpec.AssignPropertiesToNamespacesSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromNamespacesSpec populates our Namespaces_Spec from the provided source Namespaces_Spec
func (namespacesSpec *Namespaces_Spec) AssignPropertiesFromNamespacesSpec(source *v1alpha1api20210101previewstorage.Namespaces_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	namespacesSpec.AzureName = source.AzureName

	// DisableLocalAuth
	if propertyBag.Contains("DisableLocalAuth") {
		var disableLocalAuth bool
		err := propertyBag.Pull("DisableLocalAuth", &disableLocalAuth)
		if err != nil {
			return errors.Wrap(err, "pulling 'DisableLocalAuth' from propertyBag")
		}

		namespacesSpec.DisableLocalAuth = &disableLocalAuth
	} else {
		namespacesSpec.DisableLocalAuth = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption
		err := encryption.AssignPropertiesFromEncryption(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesFromEncryption()")
		}
		namespacesSpec.Encryption = &encryption
	} else {
		namespacesSpec.Encryption = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignPropertiesFromIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromIdentity()")
		}
		namespacesSpec.Identity = &identity
	} else {
		namespacesSpec.Identity = nil
	}

	// Location
	namespacesSpec.Location = genruntime.ClonePointerToString(source.Location)

	// OriginalVersion
	namespacesSpec.OriginalVersion = source.OriginalVersion

	// Owner
	namespacesSpec.Owner = source.Owner.Copy()

	// Sku
	if source.Sku != nil {
		var sku SBSku
		err := sku.AssignPropertiesFromSBSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromSBSku()")
		}
		namespacesSpec.Sku = &sku
	} else {
		namespacesSpec.Sku = nil
	}

	// Tags
	namespacesSpec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		namespacesSpec.ZoneRedundant = &zoneRedundant
	} else {
		namespacesSpec.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		namespacesSpec.PropertyBag = propertyBag
	} else {
		namespacesSpec.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNamespacesSpec populates the provided destination Namespaces_Spec from our Namespaces_Spec
func (namespacesSpec *Namespaces_Spec) AssignPropertiesToNamespacesSpec(destination *v1alpha1api20210101previewstorage.Namespaces_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(namespacesSpec.PropertyBag)

	// AzureName
	destination.AzureName = namespacesSpec.AzureName

	// DisableLocalAuth
	if namespacesSpec.DisableLocalAuth != nil {
		propertyBag.Add("DisableLocalAuth", *namespacesSpec.DisableLocalAuth)
	}

	// Encryption
	if namespacesSpec.Encryption != nil {
		var encryption v1alpha1api20210101previewstorage.Encryption
		err := (*namespacesSpec.Encryption).AssignPropertiesToEncryption(&encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesToEncryption()")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Identity
	if namespacesSpec.Identity != nil {
		var identity v1alpha1api20210101previewstorage.Identity
		err := (*namespacesSpec.Identity).AssignPropertiesToIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToIdentity()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(namespacesSpec.Location)

	// OriginalVersion
	destination.OriginalVersion = namespacesSpec.OriginalVersion

	// Owner
	destination.Owner = namespacesSpec.Owner.Copy()

	// Sku
	if namespacesSpec.Sku != nil {
		var sku v1alpha1api20210101previewstorage.SBSku
		err := (*namespacesSpec.Sku).AssignPropertiesToSBSku(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToSBSku()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(namespacesSpec.Tags)

	// ZoneRedundant
	if namespacesSpec.ZoneRedundant != nil {
		zoneRedundant := *namespacesSpec.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.SBNamespace_Status
//Generated from:
type SBNamespace_Status struct {
	Conditions                 []conditions.Condition                                 `json:"conditions,omitempty"`
	CreatedAt                  *string                                                `json:"createdAt,omitempty"`
	DisableLocalAuth           *bool                                                  `json:"disableLocalAuth,omitempty"`
	Encryption                 *Encryption_Status                                     `json:"encryption,omitempty"`
	Id                         *string                                                `json:"id,omitempty"`
	Identity                   *Identity_Status                                       `json:"identity,omitempty"`
	Location                   *string                                                `json:"location,omitempty"`
	MetricId                   *string                                                `json:"metricId,omitempty"`
	Name                       *string                                                `json:"name,omitempty"`
	PrivateEndpointConnections []PrivateEndpointConnection_Status_SubResourceEmbedded `json:"privateEndpointConnections,omitempty"`
	PropertyBag                genruntime.PropertyBag                                 `json:"$propertyBag,omitempty"`
	ProvisioningState          *string                                                `json:"provisioningState,omitempty"`
	ServiceBusEndpoint         *string                                                `json:"serviceBusEndpoint,omitempty"`
	Sku                        *SBSku_Status                                          `json:"sku,omitempty"`
	Status                     *string                                                `json:"status,omitempty"`
	SystemData                 *SystemData_Status                                     `json:"systemData,omitempty"`
	Tags                       map[string]string                                      `json:"tags,omitempty"`
	Type                       *string                                                `json:"type,omitempty"`
	UpdatedAt                  *string                                                `json:"updatedAt,omitempty"`
	ZoneRedundant              *bool                                                  `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ConvertibleStatus = &SBNamespace_Status{}

// ConvertStatusFrom populates our SBNamespace_Status from the provided source
func (sbNamespaceStatus *SBNamespace_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20210101previewstorage.SBNamespace_Status)
	if ok {
		// Populate our instance from source
		return sbNamespaceStatus.AssignPropertiesFromSBNamespaceStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210101previewstorage.SBNamespace_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = sbNamespaceStatus.AssignPropertiesFromSBNamespaceStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our SBNamespace_Status
func (sbNamespaceStatus *SBNamespace_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20210101previewstorage.SBNamespace_Status)
	if ok {
		// Populate destination from our instance
		return sbNamespaceStatus.AssignPropertiesToSBNamespaceStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210101previewstorage.SBNamespace_Status{}
	err := sbNamespaceStatus.AssignPropertiesToSBNamespaceStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignPropertiesFromSBNamespaceStatus populates our SBNamespace_Status from the provided source SBNamespace_Status
func (sbNamespaceStatus *SBNamespace_Status) AssignPropertiesFromSBNamespaceStatus(source *v1alpha1api20210101previewstorage.SBNamespace_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	sbNamespaceStatus.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CreatedAt
	sbNamespaceStatus.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// DisableLocalAuth
	if propertyBag.Contains("DisableLocalAuth") {
		var disableLocalAuth bool
		err := propertyBag.Pull("DisableLocalAuth", &disableLocalAuth)
		if err != nil {
			return errors.Wrap(err, "pulling 'DisableLocalAuth' from propertyBag")
		}

		sbNamespaceStatus.DisableLocalAuth = &disableLocalAuth
	} else {
		sbNamespaceStatus.DisableLocalAuth = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption_Status
		err := encryption.AssignPropertiesFromEncryptionStatus(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesFromEncryptionStatus()")
		}
		sbNamespaceStatus.Encryption = &encryption
	} else {
		sbNamespaceStatus.Encryption = nil
	}

	// Id
	sbNamespaceStatus.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_Status
		err := identity.AssignPropertiesFromIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromIdentityStatus()")
		}
		sbNamespaceStatus.Identity = &identity
	} else {
		sbNamespaceStatus.Identity = nil
	}

	// Location
	sbNamespaceStatus.Location = genruntime.ClonePointerToString(source.Location)

	// MetricId
	sbNamespaceStatus.MetricId = genruntime.ClonePointerToString(source.MetricId)

	// Name
	sbNamespaceStatus.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_Status_SubResourceEmbedded, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_Status_SubResourceEmbedded
			err := privateEndpointConnection.AssignPropertiesFromPrivateEndpointConnectionStatusSubResourceEmbedded(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "populating PrivateEndpointConnections from PrivateEndpointConnections, calling AssignPropertiesFromPrivateEndpointConnectionStatusSubResourceEmbedded()")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		sbNamespaceStatus.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		sbNamespaceStatus.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	sbNamespaceStatus.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ServiceBusEndpoint
	sbNamespaceStatus.ServiceBusEndpoint = genruntime.ClonePointerToString(source.ServiceBusEndpoint)

	// Sku
	if source.Sku != nil {
		var sku SBSku_Status
		err := sku.AssignPropertiesFromSBSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromSBSkuStatus()")
		}
		sbNamespaceStatus.Sku = &sku
	} else {
		sbNamespaceStatus.Sku = nil
	}

	// Status
	sbNamespaceStatus.Status = genruntime.ClonePointerToString(source.Status)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_Status
		err := systemDatum.AssignPropertiesFromSystemDataStatus(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "populating SystemData from SystemData, calling AssignPropertiesFromSystemDataStatus()")
		}
		sbNamespaceStatus.SystemData = &systemDatum
	} else {
		sbNamespaceStatus.SystemData = nil
	}

	// Tags
	sbNamespaceStatus.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	sbNamespaceStatus.Type = genruntime.ClonePointerToString(source.Type)

	// UpdatedAt
	sbNamespaceStatus.UpdatedAt = genruntime.ClonePointerToString(source.UpdatedAt)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		sbNamespaceStatus.ZoneRedundant = &zoneRedundant
	} else {
		sbNamespaceStatus.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		sbNamespaceStatus.PropertyBag = propertyBag
	} else {
		sbNamespaceStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSBNamespaceStatus populates the provided destination SBNamespace_Status from our SBNamespace_Status
func (sbNamespaceStatus *SBNamespace_Status) AssignPropertiesToSBNamespaceStatus(destination *v1alpha1api20210101previewstorage.SBNamespace_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sbNamespaceStatus.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(sbNamespaceStatus.Conditions)

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(sbNamespaceStatus.CreatedAt)

	// DisableLocalAuth
	if sbNamespaceStatus.DisableLocalAuth != nil {
		propertyBag.Add("DisableLocalAuth", *sbNamespaceStatus.DisableLocalAuth)
	}

	// Encryption
	if sbNamespaceStatus.Encryption != nil {
		var encryption v1alpha1api20210101previewstorage.Encryption_Status
		err := (*sbNamespaceStatus.Encryption).AssignPropertiesToEncryptionStatus(&encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesToEncryptionStatus()")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(sbNamespaceStatus.Id)

	// Identity
	if sbNamespaceStatus.Identity != nil {
		var identity v1alpha1api20210101previewstorage.Identity_Status
		err := (*sbNamespaceStatus.Identity).AssignPropertiesToIdentityStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToIdentityStatus()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(sbNamespaceStatus.Location)

	// MetricId
	destination.MetricId = genruntime.ClonePointerToString(sbNamespaceStatus.MetricId)

	// Name
	destination.Name = genruntime.ClonePointerToString(sbNamespaceStatus.Name)

	// PrivateEndpointConnections
	if sbNamespaceStatus.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]v1alpha1api20210101previewstorage.PrivateEndpointConnection_Status_SubResourceEmbedded, len(sbNamespaceStatus.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range sbNamespaceStatus.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection v1alpha1api20210101previewstorage.PrivateEndpointConnection_Status_SubResourceEmbedded
			err := privateEndpointConnectionItem.AssignPropertiesToPrivateEndpointConnectionStatusSubResourceEmbedded(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "populating PrivateEndpointConnections from PrivateEndpointConnections, calling AssignPropertiesToPrivateEndpointConnectionStatusSubResourceEmbedded()")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(sbNamespaceStatus.ProvisioningState)

	// ServiceBusEndpoint
	destination.ServiceBusEndpoint = genruntime.ClonePointerToString(sbNamespaceStatus.ServiceBusEndpoint)

	// Sku
	if sbNamespaceStatus.Sku != nil {
		var sku v1alpha1api20210101previewstorage.SBSku_Status
		err := (*sbNamespaceStatus.Sku).AssignPropertiesToSBSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToSBSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Status
	destination.Status = genruntime.ClonePointerToString(sbNamespaceStatus.Status)

	// SystemData
	if sbNamespaceStatus.SystemData != nil {
		var systemDatum v1alpha1api20210101previewstorage.SystemData_Status
		err := (*sbNamespaceStatus.SystemData).AssignPropertiesToSystemDataStatus(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "populating SystemData from SystemData, calling AssignPropertiesToSystemDataStatus()")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(sbNamespaceStatus.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(sbNamespaceStatus.Type)

	// UpdatedAt
	destination.UpdatedAt = genruntime.ClonePointerToString(sbNamespaceStatus.UpdatedAt)

	// ZoneRedundant
	if sbNamespaceStatus.ZoneRedundant != nil {
		zoneRedundant := *sbNamespaceStatus.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.Encryption
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/definitions/Encryption
type Encryption struct {
	KeySource                       *string                `json:"keySource,omitempty"`
	KeyVaultProperties              []KeyVaultProperties   `json:"keyVaultProperties,omitempty"`
	PropertyBag                     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RequireInfrastructureEncryption *bool                  `json:"requireInfrastructureEncryption,omitempty"`
}

// AssignPropertiesFromEncryption populates our Encryption from the provided source Encryption
func (encryption *Encryption) AssignPropertiesFromEncryption(source *v1alpha1api20210101previewstorage.Encryption) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeySource
	encryption.KeySource = genruntime.ClonePointerToString(source.KeySource)

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		keyVaultPropertyList := make([]KeyVaultProperties, len(source.KeyVaultProperties))
		for keyVaultPropertyIndex, keyVaultPropertyItem := range source.KeyVaultProperties {
			// Shadow the loop variable to avoid aliasing
			keyVaultPropertyItem := keyVaultPropertyItem
			var keyVaultProperty KeyVaultProperties
			err := keyVaultProperty.AssignPropertiesFromKeyVaultProperties(&keyVaultPropertyItem)
			if err != nil {
				return errors.Wrap(err, "populating KeyVaultProperties from KeyVaultProperties, calling AssignPropertiesFromKeyVaultProperties()")
			}
			keyVaultPropertyList[keyVaultPropertyIndex] = keyVaultProperty
		}
		encryption.KeyVaultProperties = keyVaultPropertyList
	} else {
		encryption.KeyVaultProperties = nil
	}

	// RequireInfrastructureEncryption
	if source.RequireInfrastructureEncryption != nil {
		requireInfrastructureEncryption := *source.RequireInfrastructureEncryption
		encryption.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		encryption.RequireInfrastructureEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		encryption.PropertyBag = propertyBag
	} else {
		encryption.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryption populates the provided destination Encryption from our Encryption
func (encryption *Encryption) AssignPropertiesToEncryption(destination *v1alpha1api20210101previewstorage.Encryption) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(encryption.PropertyBag)

	// KeySource
	destination.KeySource = genruntime.ClonePointerToString(encryption.KeySource)

	// KeyVaultProperties
	if encryption.KeyVaultProperties != nil {
		keyVaultPropertyList := make([]v1alpha1api20210101previewstorage.KeyVaultProperties, len(encryption.KeyVaultProperties))
		for keyVaultPropertyIndex, keyVaultPropertyItem := range encryption.KeyVaultProperties {
			// Shadow the loop variable to avoid aliasing
			keyVaultPropertyItem := keyVaultPropertyItem
			var keyVaultProperty v1alpha1api20210101previewstorage.KeyVaultProperties
			err := keyVaultPropertyItem.AssignPropertiesToKeyVaultProperties(&keyVaultProperty)
			if err != nil {
				return errors.Wrap(err, "populating KeyVaultProperties from KeyVaultProperties, calling AssignPropertiesToKeyVaultProperties()")
			}
			keyVaultPropertyList[keyVaultPropertyIndex] = keyVaultProperty
		}
		destination.KeyVaultProperties = keyVaultPropertyList
	} else {
		destination.KeyVaultProperties = nil
	}

	// RequireInfrastructureEncryption
	if encryption.RequireInfrastructureEncryption != nil {
		requireInfrastructureEncryption := *encryption.RequireInfrastructureEncryption
		destination.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		destination.RequireInfrastructureEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.Encryption_Status
//Generated from:
type Encryption_Status struct {
	KeySource                       *string                     `json:"keySource,omitempty"`
	KeyVaultProperties              []KeyVaultProperties_Status `json:"keyVaultProperties,omitempty"`
	PropertyBag                     genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	RequireInfrastructureEncryption *bool                       `json:"requireInfrastructureEncryption,omitempty"`
}

// AssignPropertiesFromEncryptionStatus populates our Encryption_Status from the provided source Encryption_Status
func (encryptionStatus *Encryption_Status) AssignPropertiesFromEncryptionStatus(source *v1alpha1api20210101previewstorage.Encryption_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeySource
	encryptionStatus.KeySource = genruntime.ClonePointerToString(source.KeySource)

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		keyVaultPropertyList := make([]KeyVaultProperties_Status, len(source.KeyVaultProperties))
		for keyVaultPropertyIndex, keyVaultPropertyItem := range source.KeyVaultProperties {
			// Shadow the loop variable to avoid aliasing
			keyVaultPropertyItem := keyVaultPropertyItem
			var keyVaultProperty KeyVaultProperties_Status
			err := keyVaultProperty.AssignPropertiesFromKeyVaultPropertiesStatus(&keyVaultPropertyItem)
			if err != nil {
				return errors.Wrap(err, "populating KeyVaultProperties from KeyVaultProperties, calling AssignPropertiesFromKeyVaultPropertiesStatus()")
			}
			keyVaultPropertyList[keyVaultPropertyIndex] = keyVaultProperty
		}
		encryptionStatus.KeyVaultProperties = keyVaultPropertyList
	} else {
		encryptionStatus.KeyVaultProperties = nil
	}

	// RequireInfrastructureEncryption
	if source.RequireInfrastructureEncryption != nil {
		requireInfrastructureEncryption := *source.RequireInfrastructureEncryption
		encryptionStatus.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		encryptionStatus.RequireInfrastructureEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		encryptionStatus.PropertyBag = propertyBag
	} else {
		encryptionStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryptionStatus populates the provided destination Encryption_Status from our Encryption_Status
func (encryptionStatus *Encryption_Status) AssignPropertiesToEncryptionStatus(destination *v1alpha1api20210101previewstorage.Encryption_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(encryptionStatus.PropertyBag)

	// KeySource
	destination.KeySource = genruntime.ClonePointerToString(encryptionStatus.KeySource)

	// KeyVaultProperties
	if encryptionStatus.KeyVaultProperties != nil {
		keyVaultPropertyList := make([]v1alpha1api20210101previewstorage.KeyVaultProperties_Status, len(encryptionStatus.KeyVaultProperties))
		for keyVaultPropertyIndex, keyVaultPropertyItem := range encryptionStatus.KeyVaultProperties {
			// Shadow the loop variable to avoid aliasing
			keyVaultPropertyItem := keyVaultPropertyItem
			var keyVaultProperty v1alpha1api20210101previewstorage.KeyVaultProperties_Status
			err := keyVaultPropertyItem.AssignPropertiesToKeyVaultPropertiesStatus(&keyVaultProperty)
			if err != nil {
				return errors.Wrap(err, "populating KeyVaultProperties from KeyVaultProperties, calling AssignPropertiesToKeyVaultPropertiesStatus()")
			}
			keyVaultPropertyList[keyVaultPropertyIndex] = keyVaultProperty
		}
		destination.KeyVaultProperties = keyVaultPropertyList
	} else {
		destination.KeyVaultProperties = nil
	}

	// RequireInfrastructureEncryption
	if encryptionStatus.RequireInfrastructureEncryption != nil {
		requireInfrastructureEncryption := *encryptionStatus.RequireInfrastructureEncryption
		destination.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		destination.RequireInfrastructureEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.Identity
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/definitions/Identity
type Identity struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignPropertiesFromIdentity populates our Identity from the provided source Identity
func (identity *Identity) AssignPropertiesFromIdentity(source *v1alpha1api20210101previewstorage.Identity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIdentity populates the provided destination Identity from our Identity
func (identity *Identity) AssignPropertiesToIdentity(destination *v1alpha1api20210101previewstorage.Identity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.Identity_Status
//Generated from:
type Identity_Status struct {
	PrincipalId            *string                                `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	TenantId               *string                                `json:"tenantId,omitempty"`
	Type                   *string                                `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_Status `json:"userAssignedIdentities,omitempty"`
}

// AssignPropertiesFromIdentityStatus populates our Identity_Status from the provided source Identity_Status
func (identityStatus *Identity_Status) AssignPropertiesFromIdentityStatus(source *v1alpha1api20210101previewstorage.Identity_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identityStatus.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identityStatus.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identityStatus.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_Status, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_Status
			err := userAssignedIdentity.AssignPropertiesFromDictionaryValueStatus(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesFromDictionaryValueStatus()")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identityStatus.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identityStatus.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identityStatus.PropertyBag = propertyBag
	} else {
		identityStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIdentityStatus populates the provided destination Identity_Status from our Identity_Status
func (identityStatus *Identity_Status) AssignPropertiesToIdentityStatus(destination *v1alpha1api20210101previewstorage.Identity_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identityStatus.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identityStatus.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identityStatus.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identityStatus.Type)

	// UserAssignedIdentities
	if identityStatus.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1alpha1api20210101previewstorage.DictionaryValue_Status, len(identityStatus.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identityStatus.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v1alpha1api20210101previewstorage.DictionaryValue_Status
			err := userAssignedIdentityValue.AssignPropertiesToUserAssignedIdentityStatus(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesToUserAssignedIdentityStatus()")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.PrivateEndpointConnection_Status_SubResourceEmbedded
//Generated from:
type PrivateEndpointConnection_Status_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SystemData  *SystemData_Status     `json:"systemData,omitempty"`
}

// AssignPropertiesFromPrivateEndpointConnectionStatusSubResourceEmbedded populates our PrivateEndpointConnection_Status_SubResourceEmbedded from the provided source PrivateEndpointConnection_Status_SubResourceEmbedded
func (privateEndpointConnectionStatusSubResourceEmbedded *PrivateEndpointConnection_Status_SubResourceEmbedded) AssignPropertiesFromPrivateEndpointConnectionStatusSubResourceEmbedded(source *v1alpha1api20210101previewstorage.PrivateEndpointConnection_Status_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	privateEndpointConnectionStatusSubResourceEmbedded.Id = genruntime.ClonePointerToString(source.Id)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_Status
		err := systemDatum.AssignPropertiesFromSystemDataStatus(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "populating SystemData from SystemData, calling AssignPropertiesFromSystemDataStatus()")
		}
		privateEndpointConnectionStatusSubResourceEmbedded.SystemData = &systemDatum
	} else {
		privateEndpointConnectionStatusSubResourceEmbedded.SystemData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		privateEndpointConnectionStatusSubResourceEmbedded.PropertyBag = propertyBag
	} else {
		privateEndpointConnectionStatusSubResourceEmbedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateEndpointConnectionStatusSubResourceEmbedded populates the provided destination PrivateEndpointConnection_Status_SubResourceEmbedded from our PrivateEndpointConnection_Status_SubResourceEmbedded
func (privateEndpointConnectionStatusSubResourceEmbedded *PrivateEndpointConnection_Status_SubResourceEmbedded) AssignPropertiesToPrivateEndpointConnectionStatusSubResourceEmbedded(destination *v1alpha1api20210101previewstorage.PrivateEndpointConnection_Status_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(privateEndpointConnectionStatusSubResourceEmbedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(privateEndpointConnectionStatusSubResourceEmbedded.Id)

	// SystemData
	if privateEndpointConnectionStatusSubResourceEmbedded.SystemData != nil {
		var systemDatum v1alpha1api20210101previewstorage.SystemData_Status
		err := (*privateEndpointConnectionStatusSubResourceEmbedded.SystemData).AssignPropertiesToSystemDataStatus(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "populating SystemData from SystemData, calling AssignPropertiesToSystemDataStatus()")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.SBSku
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/definitions/SBSku
type SBSku struct {
	Capacity    *int                   `json:"capacity,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignPropertiesFromSBSku populates our SBSku from the provided source SBSku
func (sbSku *SBSku) AssignPropertiesFromSBSku(source *v1alpha1api20210101previewstorage.SBSku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Capacity
	sbSku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sbSku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sbSku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		sbSku.PropertyBag = propertyBag
	} else {
		sbSku.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSBSku populates the provided destination SBSku from our SBSku
func (sbSku *SBSku) AssignPropertiesToSBSku(destination *v1alpha1api20210101previewstorage.SBSku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sbSku.PropertyBag)

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sbSku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sbSku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sbSku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.SBSku_Status
//Generated from:
type SBSku_Status struct {
	Capacity    *int                   `json:"capacity,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignPropertiesFromSBSkuStatus populates our SBSku_Status from the provided source SBSku_Status
func (sbSkuStatus *SBSku_Status) AssignPropertiesFromSBSkuStatus(source *v1alpha1api20210101previewstorage.SBSku_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Capacity
	sbSkuStatus.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sbSkuStatus.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sbSkuStatus.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		sbSkuStatus.PropertyBag = propertyBag
	} else {
		sbSkuStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSBSkuStatus populates the provided destination SBSku_Status from our SBSku_Status
func (sbSkuStatus *SBSku_Status) AssignPropertiesToSBSkuStatus(destination *v1alpha1api20210101previewstorage.SBSku_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sbSkuStatus.PropertyBag)

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sbSkuStatus.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sbSkuStatus.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sbSkuStatus.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.SystemData_Status
//Generated from:
type SystemData_Status struct {
	CreatedAt          *string                `json:"createdAt,omitempty"`
	CreatedBy          *string                `json:"createdBy,omitempty"`
	CreatedByType      *string                `json:"createdByType,omitempty"`
	LastModifiedAt     *string                `json:"lastModifiedAt,omitempty"`
	LastModifiedBy     *string                `json:"lastModifiedBy,omitempty"`
	LastModifiedByType *string                `json:"lastModifiedByType,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromSystemDataStatus populates our SystemData_Status from the provided source SystemData_Status
func (systemDataStatus *SystemData_Status) AssignPropertiesFromSystemDataStatus(source *v1alpha1api20210101previewstorage.SystemData_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CreatedAt
	systemDataStatus.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	systemDataStatus.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	systemDataStatus.CreatedByType = genruntime.ClonePointerToString(source.CreatedByType)

	// LastModifiedAt
	systemDataStatus.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	systemDataStatus.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	systemDataStatus.LastModifiedByType = genruntime.ClonePointerToString(source.LastModifiedByType)

	// Update the property bag
	if len(propertyBag) > 0 {
		systemDataStatus.PropertyBag = propertyBag
	} else {
		systemDataStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSystemDataStatus populates the provided destination SystemData_Status from our SystemData_Status
func (systemDataStatus *SystemData_Status) AssignPropertiesToSystemDataStatus(destination *v1alpha1api20210101previewstorage.SystemData_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(systemDataStatus.PropertyBag)

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(systemDataStatus.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(systemDataStatus.CreatedBy)

	// CreatedByType
	destination.CreatedByType = genruntime.ClonePointerToString(systemDataStatus.CreatedByType)

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(systemDataStatus.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(systemDataStatus.LastModifiedBy)

	// LastModifiedByType
	destination.LastModifiedByType = genruntime.ClonePointerToString(systemDataStatus.LastModifiedByType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.KeyVaultProperties
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/definitions/KeyVaultProperties
type KeyVaultProperties struct {
	Identity    *UserAssignedIdentityProperties `json:"identity,omitempty"`
	KeyName     *string                         `json:"keyName,omitempty"`
	KeyVaultUri *string                         `json:"keyVaultUri,omitempty"`
	KeyVersion  *string                         `json:"keyVersion,omitempty"`
	PropertyBag genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromKeyVaultProperties populates our KeyVaultProperties from the provided source KeyVaultProperties
func (keyVaultProperties *KeyVaultProperties) AssignPropertiesFromKeyVaultProperties(source *v1alpha1api20210101previewstorage.KeyVaultProperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentityProperties
		err := identity.AssignPropertiesFromUserAssignedIdentityProperties(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromUserAssignedIdentityProperties()")
		}
		keyVaultProperties.Identity = &identity
	} else {
		keyVaultProperties.Identity = nil
	}

	// KeyName
	keyVaultProperties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	keyVaultProperties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	keyVaultProperties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		keyVaultProperties.PropertyBag = propertyBag
	} else {
		keyVaultProperties.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultProperties populates the provided destination KeyVaultProperties from our KeyVaultProperties
func (keyVaultProperties *KeyVaultProperties) AssignPropertiesToKeyVaultProperties(destination *v1alpha1api20210101previewstorage.KeyVaultProperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(keyVaultProperties.PropertyBag)

	// Identity
	if keyVaultProperties.Identity != nil {
		var identity v1alpha1api20210101previewstorage.UserAssignedIdentityProperties
		err := (*keyVaultProperties.Identity).AssignPropertiesToUserAssignedIdentityProperties(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToUserAssignedIdentityProperties()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(keyVaultProperties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(keyVaultProperties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(keyVaultProperties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.KeyVaultProperties_Status
//Generated from:
type KeyVaultProperties_Status struct {
	Identity    *UserAssignedIdentityProperties_Status `json:"identity,omitempty"`
	KeyName     *string                                `json:"keyName,omitempty"`
	KeyVaultUri *string                                `json:"keyVaultUri,omitempty"`
	KeyVersion  *string                                `json:"keyVersion,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromKeyVaultPropertiesStatus populates our KeyVaultProperties_Status from the provided source KeyVaultProperties_Status
func (keyVaultPropertiesStatus *KeyVaultProperties_Status) AssignPropertiesFromKeyVaultPropertiesStatus(source *v1alpha1api20210101previewstorage.KeyVaultProperties_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentityProperties_Status
		err := identity.AssignPropertiesFromUserAssignedIdentityPropertiesStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromUserAssignedIdentityPropertiesStatus()")
		}
		keyVaultPropertiesStatus.Identity = &identity
	} else {
		keyVaultPropertiesStatus.Identity = nil
	}

	// KeyName
	keyVaultPropertiesStatus.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	keyVaultPropertiesStatus.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	keyVaultPropertiesStatus.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		keyVaultPropertiesStatus.PropertyBag = propertyBag
	} else {
		keyVaultPropertiesStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultPropertiesStatus populates the provided destination KeyVaultProperties_Status from our KeyVaultProperties_Status
func (keyVaultPropertiesStatus *KeyVaultProperties_Status) AssignPropertiesToKeyVaultPropertiesStatus(destination *v1alpha1api20210101previewstorage.KeyVaultProperties_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(keyVaultPropertiesStatus.PropertyBag)

	// Identity
	if keyVaultPropertiesStatus.Identity != nil {
		var identity v1alpha1api20210101previewstorage.UserAssignedIdentityProperties_Status
		err := (*keyVaultPropertiesStatus.Identity).AssignPropertiesToUserAssignedIdentityPropertiesStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToUserAssignedIdentityPropertiesStatus()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(keyVaultPropertiesStatus.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(keyVaultPropertiesStatus.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(keyVaultPropertiesStatus.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.UserAssignedIdentity_Status
//Generated from:
type UserAssignedIdentity_Status struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

//Storage version of v1alpha1api20210601preview.UserAssignedIdentityProperties
//Generated from: https://schema.management.azure.com/schemas/2021-06-01-preview/Microsoft.ServiceBus.json#/definitions/UserAssignedIdentityProperties
type UserAssignedIdentityProperties struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	//UserAssignedIdentityReference: ARM ID of user Identity selected for encryption
	UserAssignedIdentityReference *genruntime.ResourceReference `armReference:"UserAssignedIdentity" json:"userAssignedIdentityReference,omitempty"`
}

// AssignPropertiesFromUserAssignedIdentityProperties populates our UserAssignedIdentityProperties from the provided source UserAssignedIdentityProperties
func (userAssignedIdentityProperties *UserAssignedIdentityProperties) AssignPropertiesFromUserAssignedIdentityProperties(source *v1alpha1api20210101previewstorage.UserAssignedIdentityProperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// UserAssignedIdentityReference
	if source.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := source.UserAssignedIdentityReference.Copy()
		userAssignedIdentityProperties.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		userAssignedIdentityProperties.UserAssignedIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		userAssignedIdentityProperties.PropertyBag = propertyBag
	} else {
		userAssignedIdentityProperties.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentityProperties populates the provided destination UserAssignedIdentityProperties from our UserAssignedIdentityProperties
func (userAssignedIdentityProperties *UserAssignedIdentityProperties) AssignPropertiesToUserAssignedIdentityProperties(destination *v1alpha1api20210101previewstorage.UserAssignedIdentityProperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(userAssignedIdentityProperties.PropertyBag)

	// UserAssignedIdentityReference
	if userAssignedIdentityProperties.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := userAssignedIdentityProperties.UserAssignedIdentityReference.Copy()
		destination.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		destination.UserAssignedIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Storage version of v1alpha1api20210601preview.UserAssignedIdentityProperties_Status
//Generated from:
type UserAssignedIdentityProperties_Status struct {
	PropertyBag          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UserAssignedIdentity *string                `json:"userAssignedIdentity,omitempty"`
}

// AssignPropertiesFromUserAssignedIdentityPropertiesStatus populates our UserAssignedIdentityProperties_Status from the provided source UserAssignedIdentityProperties_Status
func (userAssignedIdentityPropertiesStatus *UserAssignedIdentityProperties_Status) AssignPropertiesFromUserAssignedIdentityPropertiesStatus(source *v1alpha1api20210101previewstorage.UserAssignedIdentityProperties_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// UserAssignedIdentity
	userAssignedIdentityPropertiesStatus.UserAssignedIdentity = genruntime.ClonePointerToString(source.UserAssignedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		userAssignedIdentityPropertiesStatus.PropertyBag = propertyBag
	} else {
		userAssignedIdentityPropertiesStatus.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentityPropertiesStatus populates the provided destination UserAssignedIdentityProperties_Status from our UserAssignedIdentityProperties_Status
func (userAssignedIdentityPropertiesStatus *UserAssignedIdentityProperties_Status) AssignPropertiesToUserAssignedIdentityPropertiesStatus(destination *v1alpha1api20210101previewstorage.UserAssignedIdentityProperties_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(userAssignedIdentityPropertiesStatus.PropertyBag)

	// UserAssignedIdentity
	destination.UserAssignedIdentity = genruntime.ClonePointerToString(userAssignedIdentityPropertiesStatus.UserAssignedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Namespace{}, &NamespaceList{})
}
